/* QWAK ("Qlosure With A K") Lisp interpreter
 Copyright (C) 2023-2025 Ave Tealeaf

This file is part of QWAK Lisp.

QWAK Lisp is free software: you can redistribute it and/or modify it under
 the terms of the GNU Lesser General Public License, version 3 or later, as
 published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 for more details.

You should have received a copy of the GNU Lesser General Public License
 along with this program. If not, see <https://www.gnu.org/licenses/>. */

#ifndef QWAKLISP
#define QWAKLISP

#include<stdio.h>
#include<stdlib.h> // exit(), for error handling

// ~~~ memory stuff ~~~

#define MAX 0x4000
#define MSTR 0x2000
int mem[MAX],lm,ls,lh,lg; // last cons, last symb, first str, first guard
char str[MSTR],la,DEBUG=0;FILE*fd;
const char initmem[]="nil\0defun\0lambda\0cond\0"
	"eq\0car\0cdr\0cons\0quote\0print\0mem\0+\0-\0*\0/\0%\0"
	"begin\0set\0if\0case\0putc\0getc\0seek\0let\0close\0str\0"
	"str-set\0list\0macro\0itoa\0atoi\0type\0at\0"
	"vec\0vec-set\0vec-len\0str-len\0str-free\0";
char rwmem[MSTR];int rwat;

// atom num pair

enum{ // autogenerated. bad. does make evsing() a lot more readable tho
	// *and* reordering the builtin symbols or adding new ones is a *lot* easier!
	L_NIL=0, L_DEFUN=L_NIL+4, L_LAMBDA=L_DEFUN+6,
	L_COND=L_LAMBDA+7, L_EQ=L_COND+5, L_CAR=L_EQ+3,
	L_CDR=L_CAR+4, L_CONS=L_CDR+4, L_QUOTE=L_CONS+5, L_PRINT=L_QUOTE+6,
	L_MEM=L_PRINT+6, L_ADD=L_MEM+4, L_SUB=L_ADD+2, L_MLT=L_SUB+2,
	L_DIV=L_MLT+2, L_MOD=L_DIV+2, L_BEGIN=L_MOD+2, L_SET=L_BEGIN+6,
	L_IF=L_SET+4, L_CASE=L_IF+3, L_PUTC=L_CASE+5, L_GETC=L_PUTC+5,
	L_SEEK=L_GETC+5, L_LET=L_SEEK+5, L_CLOSE=L_LET+4, L_STR=L_CLOSE+6,
	L_STRSET=L_STR+4, L_LIST=L_STRSET+8, L_MACRO=L_LIST+5,
	L_ITOA=L_MACRO+6, L_ATOI=L_ITOA+5, L_TYPE=L_ATOI+5, L_AT=L_TYPE+5,
	L_VEC=L_AT+3, L_VECSET=L_VEC+4, L_VECLEN=L_VECSET+8,
	L_STRLEN=L_VECLEN+8, L_STRFREE=L_STRLEN+8, L_END=L_STRFREE+9
};



// tags: pair num symb (vec  str err1 err2)
//        00   01  10  0011 0111 1011 1111
#define iscons(x) (x&&((x&3)==0)) // nil not considered a valid concell
#define isnum(x) ((x&3)==1)
#define issym(x) ((x&3)==2)
#define isvec(x) ((x&15)==3)
#define isstr(x) ((x&15)==7)
#define tagnum(x) ((x<<2)|1)
#define tagsym(x) ((x<<2)|2)
#define tagvec(x) ((x<<4)|3)
#define tagstr(x) ((x<<4)|7)
#define getsym(x) ((x>>2)+str)
#define getstr(x) ((x>>4)+str)
//#define getstr(x) ((x>>4)+str+1) // strmem
#define car(x) mem[x>>1] // neat!
#define cdr(x) mem[(x>>1)+1]
#define gcdr(x) ((car(x)>>1)+1) // for `set`
#define dpr(lvl,...) if(DEBUG>lvl)printf(__VA_ARGS__)

void printmem(int*);

void hcf(int err){
	printf("%i,%i/%i of %i/%i used\n",lm<<1,MAX-lg,ls,MAX,MSTR);
	//if(err)printmem(&err);
	fd=fopen("coredump","w");
	for(int i=0;i<MSTR;i++){
		//fputc(rwmem[i]>>8,fd); // only outputting ascii for now
		fputc(rwmem[i],fd);
	}fclose(fd);exit(err);
}

int cons(int car,int cdr){
	if((lm<<1)>lg)printf("err: out of cons memory!\n"),hcf(-1);
	//int at=lm<<1;mem[at++]=car;mem[at++]=cdr;
	mem[lm<<1]=car;mem[(lm<<1)+1]=cdr;
	return(lm++)<<2;
}

int intern(){ // adapted from sectorlisp
	for(int i=0;i<ls;){ // iterates over strings in memory
		char c=str[i++];
		for(int j=0;;j++){
			if(c!=str[ls+j])break; // char dont match, stop testing
			if(!c)return tagsym(i-j-1); // above makes sure c==str[ls+j]
			c=str[i++];
		}if(c)while(str[i++]);} // reels to beginning of next string if not at end
	int ret=tagsym(ls);while(str[ls++]);
	if(ls>MSTR)printf("err: out of symbol memory!\n"),hcf(-1);
	return ret;
}

int chkstr(){int ret=0; // check if number
	for(int i=ls;str[i];i++){ret=ret*10+str[i]-'0';
		if(str[i]<'0' || '9'<str[i])return intern();
	}return tagnum(ret);
}

//#include"strmem.h" // contains routines for heap hole list XXX put in-place
// have to adapt various parts to make this cooperate, but also it dont work
//  yet. putting said adaptations in comments for now. main difference is that
//  strings need to be tagged for length (as vectors currently/already are)



// ~~~ parsing ~~~

#define iswhite() (la==' '||la=='\n'||la=='\t')
#define getnext() (la=getc(fd))
char white(){while(1){
	if(iswhite())getnext();else
	if(la==';')while(la!=10)getnext();
	else break;}
}

int parse(char flags){
	/* flags (only 'iterate' valid as argument):
	 * 1 - whether to iterate parsing, or return a single token (for repl)
	 * 2 - dotpair also doesnt iterate, but we skip remaining args
	 * 4 - whether we're autoquoting */
	if((lm<<1)>=lg || ls>=lh)printf("err: out of parse memory!\n"),hcf(-1);
	white();if(la==')' || la==EOF){getnext();return 0;}

	flags&=1; // enforce input flag correctness (just in case)
	int ret=0,head=0;
	if(la=='.'){getnext();white();flags|=2;}else if(flags&1)ret=cons(0,0);
	if(la=='\'')flags|=4,getnext();
	if(la=='#')head=tagnum(getnext());
	else if(la=='(')getnext(),head=parse(1);
	else if(la=='"'){
		char*s=str+ls;int len=1;getnext(); // 1 for nil terminator
		while(la!='"' && la!=EOF)*s++=la,len++,getnext();
		*s=0,getnext();
		lh-=len; // replace w/ below for strmem
		for(int i=0;i<len;i++)str[lh+i]=str[ls+i];
		head=tagstr(lh);
		/*head=strmalloc(len);s=getstr(head);
		for(int i=0;i<len;i++)*s++=str[ls+i];*/
	}else{char*s=str+ls;
		while(!iswhite() && la!='(' && la!=')' && la!=EOF && ls<lh)
			*s++=la,getnext();
		*s=0;head=chkstr();
	}

	if(flags&4)head=cons(tagsym(L_QUOTE),cons(head,0));
	if(ret){car(ret)=head;cdr(ret)=parse(1);return ret;}
	if(flags&2){while(la!=')')getnext();getnext();}return head;
}



// ~~~ utility prints ~~~

//#define pprdep 5 // depth at which pprint should stop processing
int pprdep=5; // easier to store a global val that we modify temporarily
void pprint_(int i,int d){
	if(!i){printf("nil");return;}
	if((i&15)==15){printf("ERR");return;} // differentiate?
	if(issym(i)){printf("'%s'",getsym(i));return;}
	if(isstr(i)){printf("\"%s\"",getstr(i));return;}
	//if(isstr(mem[i]))w+=printf("\"%s\"(%i)",getstr(mem[i]),str[mem[i]>>4]);
	if(isnum(i)){printf("#%i",i>>2);return;}
	if(isvec(i)){printf("<%i@%i>",mem[i>>3]>>1,i>>3);return;}
	if(!d){printf("<etc>");return;}else d--;
	if(car(i)==434){printf("(closure)");return;}
	putchar('(');int maxlst=pprdep;
	while(iscons(i)&&maxlst--){
		pprint_(car(i),d);i=cdr(i);if(i)putchar(' ');
	}if(i)printf(". "),pprint_(i,0);
	if(i&&!maxlst)printf("<etc>");putchar(')');
}

void pprint(int i){pprint_(i,pprdep);putchar(10);}

void printmem(int*env){ // XXX handling of lm could be better
	// XXX requiring env as param is kinda stupid tbh
	// XXX does not handle (all) types properly
	printf("mem use %i/%i of %i/%i, env is %i",lm<<1,ls,MAX,MSTR,*env>>1);
	int w=0;
	for(int i=0;i<(lm<<1);i++){
		if(i&1)while(w++<20)putchar(' ');else putchar(10);
		w=printf("% 4i:",i);
		if(issym(mem[i]))w+=printf("'%s'",getsym(mem[i]));
		else if(isstr(mem[i]))w+=printf("\"%s\"",getstr(mem[i]));
		else if(isnum(mem[i]))w+=printf("#%i",mem[i]>>2);
		else if(isvec(mem[i]))w+=printf("<%i@%i>",mem[mem[i]>>3]>>1,mem[i]>>3);
		else w+=printf(" %i",mem[i]>>1); // XXX iserr
	}printf("\n");int i=0;
	while(i<ls){printf(" %i:",i);while(str[i])putchar(str[i++]);
		while(!str[i] && i<ls)i++;}printf("\n\n"); // since there might be gaps
	// XXX above does not account for heap-like holelisted mem
}

void printenv(int*env){printf("env (%i) binds: ",*env);
	for(int t=*env;t;t=cdr(t)){
		if(!iscons(t)){printf("env broke at %i!",t);break;}
		if(!iscons(car(t))){printf("var broke at %i!",car(t));break;}
		printf("%s,",getsym(car(car(t))));
	}putchar(10);
}



// ~~~ garbage collector (read up on SectorLISP if it makes no sense) ~~~

int garbage(int keep,int min,int max){
	// keep is ptr to non-grb, min is lm b4 grb, min is diff to top (lm-min)
	// collect() accounts for lm shifting, we use absolute indices
	//dpr(2," g %i\n",keep);
	if(keep<min||issym(keep)||isnum(keep)||isstr(keep))return keep;
	if((keep&0xff)==0xff)printf("err: gc messed up\n"),hcf(-1);
	if(car(keep)==0x7fff)return cdr(keep); // already processed
	if(isvec(keep)){
		keep>>=3; // memaddr
		// s is (total) vector length, t is beginning of free mem
		int s=mem[keep]>>1,t=lm<<1;lm+=s>>1;
		//dpr(2," vec of len %i\n",s);
		for(int i=0;i<s;i++){
			mem[t+i]=mem[keep+i];
			mem[keep+i]=0xffff;
		}mem[keep]=0x7fff;
		mem[keep+1]=tagvec(t>>1)-max;
		for(int i=1;i<s;i++)mem[t+i]=garbage(mem[t+i],min,max);
		return tagvec(t>>1)-(max<<2);
	}
	int t=cons(car(keep),cdr(keep));
	dpr(2,"  gc %i -> %i\n",keep>>1,(t-max)>>1);
	car(keep)=0x7fff,cdr(keep)=t-max;
	car(t)=garbage(car(t),min,max);
	cdr(t)=garbage(cdr(t),min,max);
	return t-max;
}

int collect(int keep,int*env,int before){
	// keep is stuff to keep, before is top of mem before we called stuff
	if(before==lm){dpr(2,"no garbage!\n");return keep;}
	before<<=1;int after=lm<<1; // XXX double *again*, for below?
	dpr(2,"gc %i from %i-%i : ",keep,before,after),pprint(keep);
	if(DEBUG>3)printmem(env);

	keep=garbage(keep,before*2,(after-before)*2); // takes care of types
	dpr(2,"gc env from %i\n",*env);
	*env=garbage(*env,before*2,(after-before)*2); // stupid...
	dpr(2,"gc env  to  %i\n",*env);

	if(DEBUG>2&&lg<MAX){printf(" guards %i: ",MAX-lg);for(int i=lg;i<MAX;i++)
		printf("%i, ",mem[i]);putchar(10);}

	for(int at=lg;at<MAX;at++){ // guards processed separately
		dpr(2," guard %i : %i :",mem[at],mem[mem[at]]),pprint(mem[mem[at]]);
		if(mem[at]==0); // not worth compacting here
		else if(mem[at&~1]==0x7fff)mem[at]=at+1; // guarded binding gc'd
		else if(mem[mem[at]]==0xffff)mem[at]=0; // as above
		else if(mem[mem[at]]==0x7fff)mem[at]=(mem[at]>>1)+1;
		else mem[mem[at]]=garbage(mem[mem[at]],before*2,(after-before)*2);
		dpr(2,"  moved to %i\n",mem[mem[at]]);
	}

	// anything under 'before' is not touched
	// 'after' is how much was taken by eval
	// lm is how much extra we took
	//before>>=1,after>>=1; // since were doing manual addressing now
	dpr(2,"gc %i  to  %i-%i in %i :",keep,before,after,lm);
	//int t=lm<<1;
	while((lm<<1)>after)mem[before++]=mem[after++];
	for(int i=before;i<after;i++)mem[i]=0xffff;
	if(DEBUG>2)pprint(keep); // has to be after transfer
	lm=before>>1; // this should be correct
	if(DEBUG>3)printmem(env);
	return keep;
}

// arguments to the following are where the object to guard is stored

void passguards(int keep){
	if(!iscons(mem[keep]))return;
	for(int at=lg;at<MAX;at++) // very inefficient - no better ideas?
		if(mem[at]==keep)mem[at]=0;
	int t=car(keep);car(keep)=0; // gently abusing c stack memory
	passguards(t);car(keep)=t;
	t=cdr(keep);cdr(keep)=0;
	passguards(t);cdr(keep)=t;
}

void guard(int keep){ // make it return where the guard was set?
	if(!iscons(mem[keep]))return;
	for(int at=lg;at<MAX;at++)if(mem[at]==keep)return;
	dpr(2,"guarding %i : %i :",keep,mem[keep]),pprint(mem[keep]);
	int shift=0; // compact
	for(int i=MAX-1;i>lg;i--){
		if(shift)mem[i]=mem[i-shift];
		while(!mem[i] && i>lg)
			shift++,lg++,mem[i]=mem[i-shift];
	}if(shift)dpr(2,"removed %i guards\n",shift);
	mem[--lg]=keep;
}



// ~~~ interpreter ~~~

int latoi(int index){ // from spc
	char*s=getstr(index),inv=0;int ret=0; // XXX string or symbol?
	dpr(0,"- atoi %s\n",s);
	if(*s=='-'){inv=1;s++;}
	while('0'<=*s&&*s<='9')ret=ret*10+*s++ -'0';
	if(inv)ret*=-1;return tagnum(ret);
}

int litoa(int x){x>>=2; // who even needs printf?
	char*s=str+ls,swap,i;
	if(!x)*s++='0';
	while(x)*s++=(x%10)+'0',x/=10; // stringmem check handled by intern
	*s=0,i=s-(str+ls);
	for(int j=0;j<i>>1;j++){
		swap=str[ls+j];
		str[ls+j]=str[ls+i-j-1];
		str[ls+i-j-1]=swap;
	}return intern();
}

int evsing(int,int*,int*),eval(int,int*);

int evlist(int expr,int*env){ // call this when tailcalls aint an option
	while(cdr(expr)){
		collect(eval(car(expr),env),env,lm);
		expr=cdr(expr);
	}return collect(eval(car(expr),env),env,lm);
}

int eval(int expr,int*env){
	// trampoline wrapper for tailcalls - also takes care of gc
	int tramp=1,tmpenv=0,*envptr=env,before;
	while(tramp){dpr(1,"tailcall\n");
		if(tramp==1){ // tailcall
			tramp=0,before=lm;
			expr=evsing(expr,envptr,&tramp);
			if(iscons(tramp)){ // set new env
				tmpenv=tramp;envptr=&tmpenv;
				dpr(1,"tmp"),printenv(envptr);
				tramp=2; // new envs are implicitly iterated
			}else expr=collect(expr,envptr,before);
		}

		if(tramp==2){ // iterated tailcall (evlist)
			dpr(1,"evlist\n");
			tramp=1,before=lm; // since last one will be a regular tailcall
			while(cdr(expr)){
				eval(car(expr),envptr); // discard value - gc here?
				expr=cdr(expr);
			}expr=collect(car(expr),envptr,before);
		}
	}return expr;
}

int evsing(int expr,int*env,int*tramp){
	dpr(0,"- eval: "),pprint_(expr,3);
	if(!expr || expr==7){dpr(0," - nil\n");return 0;} // `nil` string also nil

	if(isnum(expr)){dpr(0," - isint\n");return expr;}

	if(isstr(expr)){dpr(0," - isstr\n");return expr;}

	if(issym(expr)){for(int bind=*env;bind;bind=cdr(bind))
		if(car(car(bind))==expr){
			dpr(0," - env: "),pprint(cdr(car(bind)));
			return cdr(car(bind));
		}dpr(0," - isself\n");return expr;
	}dpr(0,"\n");

	int op=car(expr),prev=0;
	for(int max=10;max;max--){ // icoe breaker
		if(!op)hcf(0); // (())
		if(isnum(op)){printf("err: cannot apply number\n");hcf(-1);}
		// following check makes sure op is a builtin w/ an ugly hack
		if(issym(op) && (op>>2)<L_END){op>>=2;switch(op){
			case L_BEGIN:*tramp=2;return cdr(expr);
			case L_QUOTE:return car(cdr(expr));
			case L_SET:
				for(int bind=*env;bind;bind=cdr(bind)) // pls call it 'binks' so we
					if(car(car(bind))==car(cdr(expr))){ // return car car binks
						passguards(gcdr(bind)); // remove previous guard (recursive)
						cdr(car(bind))=evlist(cdr(cdr(expr)),env);
						guard(gcdr(bind)); // make new guard
						return car(car(bind));} // to match defun
				// if no binding, fallthrough to defun
			case L_DEFUN:
				*env=cons(cons(car(cdr(expr)),0),*env);
				cdr(car(*env))=evlist(cdr(cdr(expr)),env);
				dpr(0,"- bound "),pprint(car(car(*env)));
				return car(car(*env));
			case L_LAMBDA: // retag as closure
				return cons(tagsym(L_CLOSE),cons(expr,*env));
			case L_COND:
				*tramp=2;
				for(int cond=cdr(expr);cond;cond=cdr(cond))
					if(eval(car(car(cond)),env))return cdr(car(cond));
				*tramp=0;return 0;
			case L_CASE:{
				*tramp=2;
				int cmp=eval(car(cdr(expr)),env);
				for(int cond=cdr(cdr(expr));cond;cond=cdr(cond))
					if(eval(car(car(cond)),env)==cmp || !car(car(cond))) // fallthru
						return cdr(car(cond));
				*tramp=0;return 0;}
			case L_IF:
				*tramp=1;
				if(eval(car(cdr(expr)),env))
					return car(cdr(cdr(expr)));
				if(cdr(cdr(cdr(expr))))
					return car(cdr(cdr(cdr(expr))));
				tramp=0;return 0;
			case L_LET:{
				int tmpenv=*env;
				for(int bind=car(cdr(expr));bind;bind=cdr(bind)){
					tmpenv=cons(cons(car(car(bind)), 0),tmpenv);
					cdr(car(tmpenv))=evlist(cdr(car(bind)),&tmpenv);
				}*tramp=tmpenv;
				return cdr(cdr(expr));}
			case L_CLOSE:case L_MACRO:return expr;}

			int args=0,res; // evlist
			if(cdr(expr)){int arglist=cdr(expr);
				args=cons(eval(car(arglist),env),0); // XXX assumes we *have* args
				res=args;arglist=cdr(arglist);
				while(arglist){
					cdr(res)=cons(eval(car(arglist),env),0);
					arglist=cdr(arglist);res=cdr(res);
			}}res=0;dpr(0,"- apply %s (%i) to ",getsym(op<<2),op),pprint(args);

			switch(op){
			// XXX print returns its args?
			//case 51: dpr(0,"out: ");pprint(car(args)); return 0; // print
			case L_PRINT:
				dpr(0,"out: ");
				if(cdr(args) && iscons(cdr(args)) && isnum(car(cdr(args))))
					pprdep=car(cdr(args))>>2;
				pprint(car(args));
				pprdep=5; // reset default print depth
				return car(args);
			case L_MEM: printmem(env); return 0;
			case L_CONS:  return cons(car(args),car(cdr(args)));
			case L_CAR:  return car(car(args));
			case L_CDR:  return cdr(car(args));
			case L_TYPE:
				if(!car(args))return tagnum(0);
				if(iscons(car(args)))return tagnum(1);
				if(isnum(car(args)))return tagnum(2);
				if(issym(car(args)))return tagnum(3);
				if(isvec(car(args)))return tagnum(4);
				if(isstr(car(args)))return tagnum(5);
				return 0;
			case L_EQ:  return car(args)==car(cdr(args))?1:0;
			case L_LIST: return args; // neat

			case L_ITOA: return litoa(car(args));
			case L_ATOI: return latoi(car(args));

			case L_GETC: return rwmem[rwat++];
			case L_PUTC: return rwmem[rwat++]=car(args)>>2;
			case L_SEEK: return rwat=car(args)>>2;

			case L_AT:
				if(iscons(car(args))){
					int at=car(args),ind=car(cdr(args))>>2;
					while(iscons(at)&&ind--)at=cdr(at);
					if(iscons(at))return car(at);
					return 0;}
				if(issym(car(args)))
					return tagnum(getsym(car(args))[car(cdr(args))>>2]);
				if(isvec(car(args))){
					if((car(cdr(args))>>3)+1 > mem[car(args)>>3])return 0; // bounds chk
					return mem[(car(args)>>3)+(car(cdr(args))>>2)+1];}
				if(isstr(car(args)))
					return tagnum(getstr(car(args))[car(cdr(args))>>2]);
				return 0;

			case L_STR:
				lh-=car(args)>>2; // allocate from the back
				return tagstr(lh);
				//return strmalloc(car(args)>>2); // strmem
			case L_STRSET:
				getstr(car(args))[car(cdr(args))>>2]=car(cdr(cdr(args)))>>2;
				return 0;
			case L_STRLEN:return tagnum(str[car(args)>>4]);
			case L_STRFREE:
				//strfree(car(args)>>4); // strmem
				return 0; // nop in this version

			case L_VEC:{
				int len=(car(args)>>3)+1; // in concells. occasionally allocates +1
				res=lm;mem[res<<1]=tagnum(len);lm+=len;
				for(int i=1;i<(len<<1);i++)mem[(res<<1)+i]=0;
				return tagvec(res);}
			case L_VECSET:{
				if((car(cdr(args))>>3)+1 > mem[car(args)>>3])return 0; // bounds chk
				int at=(car(args)>>3)+(car(cdr(args))>>2)+1;
				passguards(at);
				mem[at]=car(cdr(cdr(args)));
				guard(at);return 0;}
			case L_VECLEN:
				return((mem[car(args)>>3]<<1)-4)^3; // no size check here

			// XXX bignums would be nice
			case L_ADD:
				for(res=0;args;args=cdr(args))res+=car(args)>>2;
				return tagnum(res);
			case L_MLT:
				for(res=1;args;args=cdr(args))res*=car(args)>>2;
				return tagnum(res);
			case L_SUB:res=car(args)>>2; // XXX do the asm trick?
				for(args=cdr(args);args;args=cdr(args))res-=car(args)>>2;
				return tagnum(res);
			case L_DIV:res=car(args)>>2;
				for(args=cdr(args);args;args=cdr(args))res/=car(args)>>2;
				return tagnum(res);
			case L_MOD:res=car(args)>>2;
				for(args=cdr(args);args;args=cdr(args))res%=car(args)>>2;
				return tagnum(res);
			}
			// XXX stuff if its a symbol but not a builtin?
		}

		if(iscons(op)){
			if(car(op)==tagsym(L_LAMBDA) || car(op)==tagsym(L_CLOSE)){
				// defaults for lambda - ugly, but we'll cope
				int cloj=*env,names=car(cdr(op)),body=cdr(cdr(op)),vals=cdr(expr);
				if(car(op)==tagsym(L_CLOSE))cloj=cdr(cdr(op)),
					names=car(cdr(car(cdr(op)))),body=cdr(cdr(car(cdr(op))));
				for(;iscons(names)&&vals;names=cdr(names),vals=cdr(vals))
					cloj=cons(cons(car(names), eval(car(vals),env) ),cloj);
				if(issym(names)){int varargs=cons(names,0);cloj=cons(varargs,cloj);
					while(vals){cdr(varargs)=cons(eval(car(vals),env),0);
						varargs=cdr(varargs);vals=cdr(vals);}names=0;}
				if(names)printf("insufficient args!\n");
				while(iscons(names))
					cloj=cons(cons(car(names),0),cloj),names=cdr(names);
				if(names)cloj=cons(cons(names,0),cloj);
				*tramp=cloj;return body;
			}

			if(car(op)==tagsym(L_MACRO)){ // largely the same as lambdas
				dpr(0,"- macro application\n");
				int cloj=*env,names=car(cdr(op)),body=cdr(cdr(op)),vals=cdr(expr);
				for(;iscons(names)&&vals;names=cdr(names),vals=cdr(vals))
					cloj=cons(cons(car(names), car(vals) ),cloj);
				if(issym(names)){int varargs=cons(names,0);cloj=cons(varargs,cloj);
					while(vals){cdr(varargs)=cons(car(vals),0);
					varargs=cdr(varargs);vals=cdr(vals);}names=0;}
				if(names)printf("insufficient args!\n");
				while(iscons(names))
					cloj=cons(cons(car(names),0),cloj),names=cdr(names);
				body=evlist(body,&cloj);
				dpr(0,"- macro intermediary is "),pprint(body);
				*tramp=1;return body;
			}
		}

		dpr(1,"- newround %i\n",max);
		prev=op;op=eval(op,env);
		if(op==prev){dpr(1,"- newround isself\n");break;}
	}

	printf("err: cannot eval @%i/%i: ",expr,*env);pprint(expr);hcf(-1);
}



// ~~~ repl ~~~

int main(int argc,char**argv){
	lm=1;ls=L_END;lh=MSTR-1;lg=MAX;rwat=0;
	for(int i=0;i<MAX;i++)mem[i]=0;
	for(int i=0;i<L_END;i++)str[i]=initmem[i];
	for(int i=ls;i<MSTR;i++)str[i]=0;

	fd=argc>1?fopen(argv[1],"r"):stdin;
	if(!fd){printf("could not open file\n");return 0;}
	if(argc<2)printf( // XXX better formatting
		"QWAK ('Qlosure With A K') Lisp v2.4\n"
		"Copyright (C) 2023-2025 Ave Tealeaf\n\n"
		"This program is free software: you can redistribute and/or modify it "
		"under the\nterms of the GNU Lesser General Public License v3 or later.\n"
		"\nThis program is distributed in the hope that it will be useful, but "
		"WITHOUT\nANY WARRANTY; see the GNU LGPL for more details.\n\n");
	DEBUG=argc>2?argv[2][0]-'0':0;int data,env=0,before;

	while(1){
		if(argc==1)printf(">>> ");before=lm;
		getnext();data=parse(0);
		dpr(0,"input: "),pprint(data),printenv(&env);
		if(feof(fd))break;data=eval(data,&env);
		dpr(0,"(%i) ",data);printf("< ");pprint(data);
		dpr(1,"repl gc (%i):\n",env);collect(0,&env,before);
		//printmem(&env);
		while(lg<MAX)mem[lg++]=0; // no guards needed for globenv

		dpr(0,"mem:%i/%i\n\n",lm,ls);
	}putchar(10);fclose(fd);hcf(0);
}

#endif

/* reference implementation of a (usable!) lisp interpreter
currently specifically tailored/hacked to run the self-compiler

todo:
- proper vector tests
- strings (memmanagement system)
 - also for symbols?
- io ports - either bignums, or c-side array
 - will also need 'current io port' functionality, which gets messy. bindings?
- hcf if args to primfns missing (macros iffy)
- callstack traces in debugger

we dont check for missing args - which is STILL the leading cause of segfaults

r5rs defines `case` to use a *list* of matches - do we wanna?
needs static expr, leaving for later consideration

parser flags annoying, remove how?
main reason it has to be passed via argument is so it knows whether it should
 parse more than a single expr. isnt that the evlist/evsing distinction again?
mmm. reading thru that, its a bit harder to pull off than it seems...

repl cant parse `(expr)(expr)` properly
prolly cause we eat the first char (so we can do parselist in repl *and*
 files), but also im not sure how to avoid that rn

do itoa/atoi work on symbols, or strings? should we add functions to convert
 between symbols and strings (like r5rs)?
not a lot of use for em now that 'at' has type dispatch...

do we wanna add some usermode option to disable gc?

more descriptive names to the memory pointers
lm is head of concell memory
lg is tail of guard memory
ls is head of symbolic memory
lh is tail of string memory
|.....>----<.....|
^     ^    ^     ^
start tail head  end

can we have a function reference a binding outside its scope?
wait fuck nvm, thats what closures are for.
ok but:(defun f (lambda () (set x 5)))(defun x 10)(f)

`load` will be *very* useful, but how would we implement it?
cant concat files n run at once, will have to recurse
the recurse part might even be easy enough, but ill also have to refit the repl
 to be capable of switching files...
wait, do i? isnt it just one pointer?
ah, but it *will* be hard to allow issuing it as a lisp-side command...

strings have to be tagged for length for memman to work

reorder builtins

*/
